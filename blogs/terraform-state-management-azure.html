<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Terraform State Management in Azure | Mustafa Zeya</title>
    <link rel="icon" type="image/svg+xml" href="/assets/favicon.svg">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
    
    <style>
        /* Theme Variables - Same as previous blogs */
        :root {
            --primary-bg: #0a0e27;
            --secondary-bg: #1a1f3a;
            --accent-blue: #00d9ff;
            --accent-purple: #8b5cf6;
            --accent-green: #10b981;
            --accent-red: #ef4444;
            --text-primary: #ffffff;
            --text-secondary: #a1a1aa;
            --card-bg: rgba(26, 31, 58, 0.8);
            --border-color: rgba(255, 255, 255, 0.1);
            --gradient-1: linear-gradient(135deg, var(--accent-blue), var(--accent-purple));
        }

        [data-theme="light"] {
            --primary-bg: #f8fafc;
            --secondary-bg: #ffffff;
            --accent-blue: #0ea5e9;
            --accent-purple: #7c3aed;
            --accent-green: #059669;
            --accent-red: #dc2626;
            --text-primary: #1e293b;
            --text-secondary: #64748b;
            --card-bg: rgba(255, 255, 255, 0.9);
            --border-color: rgba(0, 0, 0, 0.1);
            --gradient-1: linear-gradient(135deg, var(--accent-blue), var(--accent-purple));
        }

        [data-theme="azure"] {
            --primary-bg: #0f172a;
            --secondary-bg: #1e293b;
            --accent-blue: #0078d4;
            --accent-purple: #5c2d91;
            --accent-green: #107c10;
            --accent-red: #d13438;
            --text-primary: #ffffff;
            --text-secondary: #94a3b8;
            --card-bg: rgba(30, 41, 59, 0.8);
            --border-color: rgba(0, 120, 212, 0.2);
            --gradient-1: linear-gradient(135deg, #0078d4, #5c2d91);
        }

        [data-theme="sunset"] {
            --primary-bg: #1a0b0e;
            --secondary-bg: #2d1b1e;
            --accent-blue: #ff6b9d;
            --accent-purple: #a855f7;
            --accent-green: #fbbf24;
            --accent-red: #ef4444;
            --text-primary: #fff1f2;
            --text-secondary: #fecaca;
            --card-bg: rgba(45, 27, 30, 0.8);
            --border-color: rgba(255, 107, 157, 0.2);
            --gradient-1: linear-gradient(135deg, #ff6b9d, #a855f7);
        }

        [data-theme="monochrome"] {
            --primary-bg: #000000;
            --secondary-bg: #1a1a1a;
            --accent-blue: #ffffff;
            --accent-purple: #d4d4d8;
            --accent-green: #a1a1aa;
            --accent-red: #52525b;
            --text-primary: #ffffff;
            --text-secondary: #a1a1aa;
            --card-bg: rgba(26, 26, 26, 0.8);
            --border-color: rgba(255, 255, 255, 0.1);
            --gradient-1: linear-gradient(135deg, #ffffff, #d4d4d8);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: var(--primary-bg);
            color: var(--text-primary);
            line-height: 1.7;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
            padding: 2rem;
        }

        .nav-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 3rem;
        }

        .back-btn {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            background: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            color: var(--text-primary);
            text-decoration: none;
            font-size: 0.9rem;
            transition: all 0.3s ease;
        }

        .back-btn:hover {
            transform: translateY(-2px);
            border-color: var(--accent-blue);
        }

        .article-header {
            text-align: center;
            margin-bottom: 3rem;
        }

        .article-meta {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 1rem;
            margin-bottom: 1.5rem;
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        .article-category {
            background: rgba(16, 185, 129, 0.1);
            color: var(--accent-green);
            padding: 0.3rem 0.8rem;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: 500;
        }

        .article-title {
            font-size: 2.5rem;
            font-weight: 700;
            background: var(--gradient-1);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 1rem;
            line-height: 1.2;
        }

        .article-excerpt {
            font-size: 1.1rem;
            color: var(--text-secondary);
            max-width: 600px;
            margin: 0 auto;
        }

        .article-tags {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-top: 1.5rem;
        }

        .article-tag {
            background: rgba(139, 92, 246, 0.1);
            color: var(--accent-purple);
            padding: 0.3rem 0.6rem;
            border-radius: 8px;
            font-size: 0.8rem;
            font-weight: 500;
        }

        .article-content {
            background: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: 16px;
            padding: 3rem;
            backdrop-filter: blur(20px);
        }

        .article-content h2 {
            font-size: 1.8rem;
            font-weight: 600;
            margin: 2rem 0 1rem 0;
            color: var(--text-primary);
        }

        .article-content h3 {
            font-size: 1.4rem;
            font-weight: 600;
            margin: 1.5rem 0 0.8rem 0;
            color: var(--accent-blue);
        }

        .article-content p {
            margin-bottom: 1.5rem;
            color: var(--text-secondary);
        }

        .article-content ul, .article-content ol {
            margin: 1rem 0 1.5rem 2rem;
            color: var(--text-secondary);
        }

        .article-content li {
            margin-bottom: 0.5rem;
        }

        .article-content blockquote {
            border-left: 4px solid var(--accent-blue);
            padding: 1rem 1.5rem;
            margin: 1.5rem 0;
            background: rgba(0, 217, 255, 0.05);
            border-radius: 0 8px 8px 0;
            font-style: italic;
            color: var(--text-secondary);
        }

        .code-block {
            background: var(--secondary-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1.5rem 0;
            overflow-x: auto;
        }

        .code-block pre {
            margin: 0;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9rem;
            line-height: 1.5;
        }

        .inline-code {
            background: rgba(0, 217, 255, 0.1);
            color: var(--accent-blue);
            padding: 0.2rem 0.4rem;
            border-radius: 4px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9em;
        }

        .warning-box {
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid rgba(239, 68, 68, 0.3);
            border-radius: 8px;
            padding: 1rem 1.5rem;
            margin: 1.5rem 0;
        }

        .warning-box h4 {
            color: var(--accent-red);
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .info-box {
            background: rgba(16, 185, 129, 0.1);
            border: 1px solid rgba(16, 185, 129, 0.3);
            border-radius: 8px;
            padding: 1rem 1.5rem;
            margin: 1.5rem 0;
        }

        .info-box h4 {
            color: var(--accent-green);
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .article-nav {
            margin-top: 3rem;
            padding-top: 2rem;
            border-top: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .nav-link {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            color: var(--accent-blue);
            text-decoration: none;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .nav-link:hover {
            gap: 0.8rem;
        }

        @media (max-width: 768px) {
            .container {
                padding: 1rem;
            }

            .article-content {
                padding: 2rem 1.5rem;
            }

            .article-title {
                font-size: 2rem;
            }

            .article-meta {
                flex-direction: column;
                gap: 0.5rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <nav class="nav-bar">
            <a href="/blogs" class="back-btn">
                <i class="fas fa-arrow-left"></i>
                <span>Back to Blog</span>
            </a>
            <a href="/" class="back-btn">
                <i class="fas fa-home"></i>
                <span>Portfolio</span>
            </a>
        </nav>

        <header class="article-header">
            <div class="article-meta">
                <div class="article-category">DevOps</div>
                <div>
                    <i class="fas fa-calendar"></i>
                    January 22, 2025
                </div>
                <div>
                    <i class="fas fa-clock"></i>
                    12 min read
                </div>
            </div>
            <h1 class="article-title">Advanced Terraform State Management in Azure</h1>
            <p class="article-excerpt">
                Master Terraform state management with Azure backend storage, state locking, and team collaboration. 
                Explore advanced patterns for managing complex infrastructure deployments and state file security.
            </p>
            <div class="article-tags">
                <span class="article-tag">Terraform</span>
                <span class="article-tag">State Management</span>
                <span class="article-tag">Azure Storage</span>
                <span class="article-tag">DevOps</span>
            </div>
        </header>

        <article class="article-content">
            <p>Terraform state management is one of the most critical aspects of infrastructure as code (IaC) implementations. As your infrastructure grows in complexity and your team expands, proper state management becomes essential for maintaining consistency, enabling collaboration, and ensuring security. In this comprehensive guide, we'll explore advanced Terraform state management patterns specifically designed for Azure environments.</p>

            <h2>Understanding Terraform State</h2>
            <p>Terraform state is a JSON file that tracks the mapping between your configuration files and the real-world resources. It serves several critical purposes:</p>

            <ul>
                <li><strong>Resource Mapping:</strong> Links configuration to actual Azure resources</li>
                <li><strong>Performance:</strong> Caches resource attributes to avoid unnecessary API calls</li>
                <li><strong>Dependencies:</strong> Tracks relationships between resources</li>
                <li><strong>Metadata:</strong> Stores resource metadata for decision-making</li>
            </ul>

            <div class="warning-box">
                <h4><i class="fas fa-exclamation-triangle"></i> Critical Warning</h4>
                <p>State files contain sensitive information including passwords, keys, and other secrets. Never store state files in version control or unsecured locations.</p>
            </div>

            <h2>Azure Backend Configuration</h2>
            <p>The most secure and scalable approach for Terraform state management in Azure is using Azure Storage with state locking via Azure Cosmos DB or Storage Account blob leasing.</p>

            <h3>Setting Up Azure Backend Storage</h3>
            <p>First, let's create the backend infrastructure:</p>

            <div class="code-block">
                <pre><code class="language-hcl"># backend-setup.tf
# This should be applied first to create the backend infrastructure

terraform {
  required_providers {
    azurerm = {
      source  = "hashicorp/azurerm"
      version = "~>3.0"
    }
    random = {
      source  = "hashicorp/random"
      version = "~>3.1"
    }
  }
}

provider "azurerm" {
  features {}
}

# Generate random string for unique naming
resource "random_string" "storage_suffix" {
  length  = 8
  special = false
  upper   = false
}

# Resource group for Terraform backend
resource "azurerm_resource_group" "terraform_state" {
  name     = "rg-terraform-state-${var.environment}"
  location = var.location

  tags = {
    Environment = var.environment
    Purpose     = "TerraformState"
    ManagedBy   = "Terraform"
  }
}

# Storage account for state files
resource "azurerm_storage_account" "terraform_state" {
  name                     = "tfstate${random_string.storage_suffix.result}"
  resource_group_name      = azurerm_resource_group.terraform_state.name
  location                = azurerm_resource_group.terraform_state.location
  account_tier             = "Standard"
  account_replication_type = "GRS"  # Geo-redundant for high availability
  
  # Security configurations
  min_tls_version                = "TLS1_2"
  allow_nested_items_to_be_public = false
  
  # Enable versioning and blob soft delete
  blob_properties {
    versioning_enabled = true
    
    delete_retention_policy {
      days = 30
    }
    
    container_delete_retention_policy {
      days = 30
    }
  }

  tags = {
    Environment = var.environment
    Purpose     = "TerraformState"
    ManagedBy   = "Terraform"
  }
}

# Container for state files
resource "azurerm_storage_container" "terraform_state" {
  name                  = "tfstate"
  storage_account_name  = azurerm_storage_account.terraform_state.name
  container_access_type = "private"
}

# Key Vault for storing access keys
resource "azurerm_key_vault" "terraform_state" {
  name                = "kv-tfstate-${random_string.storage_suffix.result}"
  location            = azurerm_resource_group.terraform_state.location
  resource_group_name = azurerm_resource_group.terraform_state.name
  tenant_id           = data.azurerm_client_config.current.tenant_id
  sku_name            = "standard"

  access_policy {
    tenant_id = data.azurerm_client_config.current.tenant_id
    object_id = data.azurerm_client_config.current.object_id

    secret_permissions = [
      "Get",
      "List",
      "Set",
      "Delete",
      "Purge"
    ]
  }

  tags = {
    Environment = var.environment
    Purpose     = "TerraformState"
    ManagedBy   = "Terraform"
  }
}

# Store storage account key in Key Vault
resource "azurerm_key_vault_secret" "storage_account_key" {
  name         = "terraform-backend-key"
  value        = azurerm_storage_account.terraform_state.primary_access_key
  key_vault_id = azurerm_key_vault.terraform_state.id
}

data "azurerm_client_config" "current" {}</code></pre>
            </div>

            <h3>Backend Configuration for Projects</h3>
            <p>Once the backend infrastructure is ready, configure your Terraform projects to use it:</p>

            <div class="code-block">
                <pre><code class="language-hcl"># main.tf for your project
terraform {
  required_version = ">= 1.0"
  
  required_providers {
    azurerm = {
      source  = "hashicorp/azurerm"
      version = "~>3.0"
    }
  }

  backend "azurerm" {
    resource_group_name  = "rg-terraform-state-prod"
    storage_account_name = "tfstatexyz12345"
    container_name       = "tfstate"
    key                 = "projects/web-app/terraform.tfstate"
  }
}

provider "azurerm" {
  features {}
}</code></pre>
            </div>

            <h2>State Locking Mechanisms</h2>
            <p>Azure Storage provides native blob leasing for state locking, but for more advanced scenarios, you might want additional locking mechanisms:</p>

            <h3>Enhanced State Locking with Cosmos DB</h3>
            <div class="code-block">
                <pre><code class="language-hcl"># Enhanced backend with Cosmos DB for locking
resource "azurerm_cosmosdb_account" "terraform_locks" {
  name                = "cosmos-tflock-${random_string.storage_suffix.result}"
  location            = azurerm_resource_group.terraform_state.location
  resource_group_name = azurerm_resource_group.terraform_state.name
  offer_type          = "Standard"
  kind                = "GlobalDocumentDB"

  consistency_policy {
    consistency_level = "Session"
  }

  geo_location {
    location          = azurerm_resource_group.terraform_state.location
    failover_priority = 0
  }

  tags = {
    Environment = var.environment
    Purpose     = "TerraformLocking"
    ManagedBy   = "Terraform"
  }
}

resource "azurerm_cosmosdb_sql_database" "terraform_locks" {
  name                = "terraform-locks"
  resource_group_name = azurerm_cosmosdb_account.terraform_locks.resource_group_name
  account_name        = azurerm_cosmosdb_account.terraform_locks.name
}

resource "azurerm_cosmosdb_sql_container" "terraform_locks" {
  name                = "locks"
  resource_group_name = azurerm_cosmosdb_account.terraform_locks.resource_group_name
  account_name        = azurerm_cosmosdb_account.terraform_locks.name
  database_name       = azurerm_cosmosdb_sql_database.terraform_locks.name
  partition_key_path  = "/id"
}</code></pre>
            </div>

            <h2>Multi-Environment State Management</h2>
            <p>Managing state across multiple environments requires careful planning and organization:</p>

            <h3>1. Environment-Specific Backends</h3>
            <div class="code-block">
                <pre><code class="language-hcl"># backend-configs/dev.hcl
resource_group_name  = "rg-terraform-state-dev"
storage_account_name = "tfstatedev12345"
container_name       = "tfstate"
key                 = "environments/dev/terraform.tfstate"

# backend-configs/staging.hcl
resource_group_name  = "rg-terraform-state-staging"
storage_account_name = "tfstatestaging12345"
container_name       = "tfstate"
key                 = "environments/staging/terraform.tfstate"

# backend-configs/prod.hcl
resource_group_name  = "rg-terraform-state-prod"
storage_account_name = "tfstateprod12345"
container_name       = "tfstate"
key                 = "environments/prod/terraform.tfstate"</code></pre>
            </div>

            <h3>2. Workspace-Based Organization</h3>
            <div class="code-block">
                <pre><code class="language-bash"># Initialize with different backend configs
terraform init -backend-config="backend-configs/dev.hcl"
terraform workspace new dev

terraform init -backend-config="backend-configs/staging.hcl"
terraform workspace new staging

terraform init -backend-config="backend-configs/prod.hcl"
terraform workspace new prod

# Switch between workspaces
terraform workspace select dev
terraform workspace select prod</code></pre>
            </div>

            <h2>State File Organization Patterns</h2>
            <p>Effective state organization is crucial for large-scale deployments:</p>

            <h3>1. Layered Architecture</h3>
            <div class="info-box">
                <h4><i class="fas fa-lightbulb"></i> Best Practice</h4>
                <p>Organize your infrastructure into logical layers to minimize blast radius and enable independent deployments.</p>
            </div>

            <div class="code-block">
                <pre><code class="language-text">Project Structure:
├── terraform/
│   ├── foundation/           # Core networking, DNS, etc.
│   │   ├── main.tf
│   │   └── backend.tf (key: "foundation/terraform.tfstate")
│   ├── security/            # Key Vaults, security policies
│   │   ├── main.tf
│   │   └── backend.tf (key: "security/terraform.tfstate")
│   ├── shared-services/     # Shared resources (ACR, Log Analytics)
│   │   ├── main.tf
│   │   └── backend.tf (key: "shared-services/terraform.tfstate")
│   └── applications/        # Application-specific resources
│       ├── web-app/
│       │   ├── main.tf
│       │   └── backend.tf (key: "apps/web-app/terraform.tfstate")
│       └── api-service/
│           ├── main.tf
│           └── backend.tf (key: "apps/api-service/terraform.tfstate")</code></pre>
            </div>

            <h3>2. Data Sources for Cross-Layer Dependencies</h3>
            <div class="code-block">
                <pre><code class="language-hcl"># applications/web-app/data.tf
# Reference outputs from foundation layer
data "terraform_remote_state" "foundation" {
  backend = "azurerm"
  config = {
    resource_group_name  = "rg-terraform-state-prod"
    storage_account_name = "tfstateprod12345"
    container_name       = "tfstate"
    key                 = "foundation/terraform.tfstate"
  }
}

# Reference outputs from security layer
data "terraform_remote_state" "security" {
  backend = "azurerm"
  config = {
    resource_group_name  = "rg-terraform-state-prod"
    storage_account_name = "tfstateprod12345"
    container_name       = "tfstate"
    key                 = "security/terraform.tfstate"
  }
}

# Use remote state outputs
resource "azurerm_app_service" "main" {
  name                = "app-${var.environment}"
  location            = data.terraform_remote_state.foundation.outputs.location
  resource_group_name = data.terraform_remote_state.foundation.outputs.app_rg_name
  app_service_plan_id = data.terraform_remote_state.foundation.outputs.app_service_plan_id

  site_config {
    linux_fx_version = "DOCKER|${data.terraform_remote_state.security.outputs.acr_login_server}/myapp:latest"
  }

  app_settings = {
    "DOCKER_REGISTRY_SERVER_URL"      = "https://${data.terraform_remote_state.security.outputs.acr_login_server}"
    "DOCKER_REGISTRY_SERVER_USERNAME" = data.terraform_remote_state.security.outputs.acr_admin_username
    "DOCKER_REGISTRY_SERVER_PASSWORD" = data.terraform_remote_state.security.outputs.acr_admin_password
  }
}</code></pre>
            </div>

            <h2>State Security and Access Control</h2>
            <p>Securing your Terraform state is paramount. Here are essential security measures:</p>

            <h3>1. RBAC and Access Policies</h3>
            <div class="code-block">
                <pre><code class="language-hcl"># Define custom roles for Terraform state access
resource "azurerm_role_definition" "terraform_state_reader" {
  name        = "Terraform State Reader"
  scope       = azurerm_storage_account.terraform_state.id
  description = "Can read Terraform state files"

  permissions {
    actions = [
      "Microsoft.Storage/storageAccounts/blobServices/containers/blobs/read",
      "Microsoft.Storage/storageAccounts/blobServices/containers/read"
    ]
    not_actions = []
  }

  assignable_scopes = [
    azurerm_storage_account.terraform_state.id
  ]
}

resource "azurerm_role_definition" "terraform_state_contributor" {
  name        = "Terraform State Contributor"
  scope       = azurerm_storage_account.terraform_state.id
  description = "Can read and write Terraform state files"

  permissions {
    actions = [
      "Microsoft.Storage/storageAccounts/blobServices/containers/blobs/*",
      "Microsoft.Storage/storageAccounts/blobServices/containers/*"
    ]
    not_actions = []
  }

  assignable_scopes = [
    azurerm_storage_account.terraform_state.id
  ]
}

# Assign roles to security groups
resource "azurerm_role_assignment" "developers_read" {
  scope              = azurerm_storage_account.terraform_state.id
  role_definition_id = azurerm_role_definition.terraform_state_reader.role_definition_resource_id
  principal_id       = var.developers_group_id
}

resource "azurerm_role_assignment" "devops_contribute" {
  scope              = azurerm_storage_account.terraform_state.id
  role_definition_id = azurerm_role_definition.terraform_state_contributor.role_definition_resource_id
  principal_id       = var.devops_group_id
}</code></pre>
            </div>

            <h3>2. State Encryption</h3>
            <div class="code-block">
                <pre><code class="language-hcl"># Enable encryption at rest with customer-managed keys
resource "azurerm_key_vault_key" "storage_encryption" {
  name         = "terraform-state-encryption-key"
  key_vault_id = azurerm_key_vault.terraform_state.id
  key_type     = "RSA"
  key_size     = 2048

  key_opts = [
    "decrypt",
    "encrypt",
    "sign",
    "unwrapKey",
    "verify",
    "wrapKey"
  ]
}

resource "azurerm_storage_account_customer_managed_key" "terraform_state" {
  storage_account_id = azurerm_storage_account.terraform_state.id
  key_vault_id       = azurerm_key_vault.terraform_state.id
  key_name           = azurerm_key_vault_key.storage_encryption.name
}</code></pre>
            </div>

            <h2>State Operations and Troubleshooting</h2>
            <p>Understanding state operations is crucial for troubleshooting and maintenance:</p>

            <h3>Common State Commands</h3>
            <div class="code-block">
                <pre><code class="language-bash"># List resources in state
terraform state list

# Show detailed info about a resource
terraform state show azurerm_resource_group.main

# Import existing resources
terraform import azurerm_resource_group.main /subscriptions/xxx/resourceGroups/rg-name

# Remove resources from state (without destroying)
terraform state rm azurerm_resource_group.main

# Move resources within state
terraform state mv azurerm_resource_group.old azurerm_resource_group.new

# Pull remote state to local
terraform state pull > terraform.tfstate.backup

# Push local state to remote
terraform state push terraform.tfstate

# Refresh state from actual infrastructure
terraform refresh</code></pre>
            </div>

            <h3>State Recovery and Backup</h3>
            <div class="code-block">
                <pre><code class="language-bash"># Create automated backup script
#!/bin/bash
# backup-terraform-state.sh

STORAGE_ACCOUNT="tfstateprod12345"
CONTAINER="tfstate"
BACKUP_CONTAINER="tfstate-backups"
DATE=$(date +%Y%m%d_%H%M%S)

# List all state files
az storage blob list \
  --container-name $CONTAINER \
  --account-name $STORAGE_ACCOUNT \
  --output table

# Backup specific state file
az storage blob copy start \
  --source-container $CONTAINER \
  --source-blob "environments/prod/terraform.tfstate" \
  --destination-container $BACKUP_CONTAINER \
  --destination-blob "prod_backup_${DATE}.tfstate" \
  --account-name $STORAGE_ACCOUNT

# Verify backup
az storage blob show \
  --container-name $BACKUP_CONTAINER \
  --name "prod_backup_${DATE}.tfstate" \
  --account-name $STORAGE_ACCOUNT</code></pre>
            </div>

            <h2>CI/CD Integration</h2>
            <p>Integrating state management with CI/CD pipelines requires careful consideration:</p>

            <h3>Azure DevOps Pipeline Configuration</h3>
            <div class="code-block">
                <pre><code class="language-yaml"># azure-pipelines.yml
trigger:
  branches:
    include:
    - main
    - develop
  paths:
    include:
    - terraform/

variables:
  - group: terraform-vars
  - name: terraformVersion
    value: '1.6.0'

stages:
- stage: Plan
  jobs:
  - job: TerraformPlan
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    - task: TerraformInstaller@0
      inputs:
        terraformVersion: $(terraformVersion)
    
    - task: AzureCLI@2
      displayName: 'Terraform Init'
      inputs:
        azureSubscription: 'terraform-service-connection'
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        inlineScript: |
          cd terraform/
          terraform init \
            -backend-config="resource_group_name=$(TF_STATE_RG)" \
            -backend-config="storage_account_name=$(TF_STATE_SA)" \
            -backend-config="container_name=tfstate" \
            -backend-config="key=$(Build.Repository.Name)/$(Build.SourceBranchName)/terraform.tfstate"
    
    - task: AzureCLI@2
      displayName: 'Terraform Plan'
      inputs:
        azureSubscription: 'terraform-service-connection'
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        inlineScript: |
          cd terraform/
          terraform plan -var-file="$(Build.SourceBranchName).tfvars" -out=tfplan
    
    - task: PublishPipelineArtifact@1
      inputs:
        targetPath: 'terraform/tfplan'
        artifactName: 'terraform-plan'

- stage: Apply
  condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
  jobs:
  - deployment: TerraformApply
    pool:
      vmImage: 'ubuntu-latest'
    environment: 'production'
    strategy:
      runOnce:
        deploy:
          steps:
          - task: DownloadPipelineArtifact@2
            inputs:
              artifactName: 'terraform-plan'
              targetPath: 'terraform/'
          
          - task: TerraformInstaller@0
            inputs:
              terraformVersion: $(terraformVersion)
          
          - task: AzureCLI@2
            displayName: 'Terraform Apply'
            inputs:
              azureSubscription: 'terraform-service-connection'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                cd terraform/
                terraform init \
                  -backend-config="resource_group_name=$(TF_STATE_RG)" \
                  -backend-config="storage_account_name=$(TF_STATE_SA)" \
                  -backend-config="container_name=tfstate" \
                  -backend-config="key=$(Build.Repository.Name)/main/terraform.tfstate"
                terraform apply tfplan</code></pre>
            </div>

            <h2>Monitoring and Alerting</h2>
            <p>Monitor your state files and backend for issues:</p>

            <div class="code-block">
                <pre><code class="language-hcl"># Monitoring for state file changes
resource "azurerm_monitor_action_group" "terraform_alerts" {
  name                = "terraform-state-alerts"
  resource_group_name = azurerm_resource_group.terraform_state.name
  short_name          = "tfstate"

  email_receiver {
    name          = "devops-team"
    email_address = "devops@company.com"
  }
}

resource "azurerm_monitor_activity_log_alert" "state_file_access" {
  name                = "terraform-state-access-alert"
  resource_group_name = azurerm_resource_group.terraform_state.name
  scopes              = [azurerm_storage_account.terraform_state.id]

  criteria {
    resource_id    = azurerm_storage_account.terraform_state.id
    operation_name = "Microsoft.Storage/storageAccounts/blobServices/containers/blobs/write"
    category       = "Administrative"
  }

  action {
    action_group_id = azurerm_monitor_action_group.terraform_alerts.id
  }
}

# Alert for failed state locks
resource "azurerm_monitor_metric_alert" "state_lock_failures" {
  name                = "terraform-state-lock-failures"
  resource_group_name = azurerm_resource_group.terraform_state.name
  scopes              = [azurerm_storage_account.terraform_state.id]

  criteria {
    metric_namespace = "Microsoft.Storage/storageAccounts"
    metric_name      = "Transactions"
    aggregation      = "Total"
    operator         = "GreaterThan"
    threshold        = 10

    dimension {
      name     = "ResponseType"
      operator = "Include"
      values   = ["ClientError"]
    }
  }

  action {
    action_group_id = azurerm_monitor_action_group.terraform_alerts.id
  }
}</code></pre>
            </div>

            <h2>Best Practices Summary</h2>
            <p>To wrap up, here are the key best practices for Terraform state management in Azure:</p>

            <ol>
                <li><strong>Always use remote backends</strong> for team collaboration</li>
                <li><strong>Enable state locking</strong> to prevent concurrent modifications</li>
                <li><strong>Implement proper RBAC</strong> and access controls</li>
                <li><strong>Use encryption</strong> for state files at rest and in transit</li>
                <li><strong>Organize state files logically</strong> by layer and environment</li>
                <li><strong>Implement backup and recovery</strong> procedures</li>
                <li><strong>Monitor state operations</strong> and set up alerts</li>
                <li><strong>Document state organization</strong> and access procedures</li>
                <li><strong>Regular state cleanup</strong> and maintenance</li>
                <li><strong>Test disaster recovery</strong> procedures regularly</li>
            </ol>

            <div class="warning-box">
                <h4><i class="fas fa-exclamation-triangle"></i> Critical Reminder</h4>
                <p>State files are the source of truth for your infrastructure. Losing or corrupting state files can lead to significant operational issues. Always prioritize state security and backup procedures.</p>
            </div>

            <h2>Conclusion</h2>
            <p>Effective Terraform state management in Azure requires careful planning, robust security measures, and operational discipline. By implementing the patterns and practices outlined in this guide, you can build a scalable, secure, and maintainable infrastructure management system that supports team collaboration and enterprise requirements.</p>

            <p>Remember that state management is not a one-time setup but an ongoing operational concern. Regular reviews, updates to security policies, and disaster recovery testing are essential for maintaining a healthy Terraform deployment.</p>

            <div class="article-nav">
                <a href="azure-waf-configuration-guide.html" class="nav-link">
                    <i class="fas fa-arrow-left"></i>
                    Previous Article
                </a>
                <a href="azure-network-security-groups.html" class="nav-link">
                    Next Article
                    <i class="fas fa-arrow-right"></i>
                </a>
            </div>
        </article>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
</body>
</html>
